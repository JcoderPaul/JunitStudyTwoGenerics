package MyGenericСollectionСlasses;

import MyInterfaces.MyOwnSet;

import java.util.Iterator;

public class MyOwnHashSet<T> implements MyOwnSet<T> {
        // Первоначальная емкость Set
        private static final int INITIAL_CAPACITY = 16;
        // Коэффициент загрузки, при котором мы расширим наш Set
        private static final double LOAD_FACTOR = 0.75;
        private int size = 0; // Первоначальный размер коллекции
        private Object[] array = new Object[INITIAL_CAPACITY]; // Пустой массив Entry
        /*
        Добавляем элемент, данный метод открытый и именно им
        можно воспользоваться в основном коде, в отличие от
        его перегруженной версии.
         */
        @Override
        public boolean add(T elementOfSet) {
            /*
            Если текущий размер коллекции больше или равен
            значению 'длина массива' * 0.75, то запускаем
            метод увеличивающий размер текущей коллекции.
            */
            if (size >= (array.length * LOAD_FACTOR)) {
                increaseArray(); // Увеличиваем размер коллекции в два раза
            }
            /*
            Используем наш приватный метод, чтобы
            добавить текущий spaceObject в наш Set.
            */
            boolean added = add(elementOfSet, array);
            // Если все прошло нормально, увеличиваем счетчик Set-а
            if (added) {
                size++;
            }
            return added; // Возвращаем true / false
        }
        /*
        Приватный метод, который добавляет 'груз' - объект класса SpaceObject
        в Set, с учетом предыдущих возможных изменений в первоначальной коллекции
        (изменение размера). Еще раз, в данном методе мы работаем не с нашим
        массивом напрямую, а с одной из его ячеек рассчитанной исходя из текущей
        длинны массива. Да, на вход мы принимаем массив, но в одном случае, это
        может быть исходный массив, а в другом уже увеличенный в n-раз.
        Т.е. метод унифицирован и в случае с исходным массивом нашей коллекции
        он позволяет просто его заполнять, однако в случае изменения размера
        массива (когда он увеличен в n - раз) производит перераспределение
        элементов старого массива в новом с учетом увеличенного размера.
        */
        private boolean add(T elementOfSet, Object[] dst) {
            // Расчет позиции
            int position = getElementPosition(elementOfSet, dst.length);
            /*
            Если в текущей (полученной исходя из расчетов) ячейке массива
            элементов пока нет, то создаем новый Entry объект со ссылкой
            на пустоту и помещаем в текущую ячейку массива.

            Помним, что каждая ячейка массива будет содержать всего лишь
            один элемент Entry, который будет первым элементом односвязного
            списка и будет указывать на следующий элемент этого списка, тот
            в свою очередь на следующий и т.д.

            Для того чтобы утерять всю цепочку или её часть, достаточно утерять
            одну ссылку или первый элемент цепочки (нет ссылки на объект - его
            заберет старуха с косой - сборщик мусора, даже если объекты ссылаются
            друг на друга, но на них нет ссылки из стека, хотя бы на один,
            они пойдут в расход)
            */
            if (dst[position] == null) {
                // Формируем начало односвязного списка, получаем первый элемент
                Entry entry = new Entry(elementOfSet, null);
                dst[position] = entry;
                return true; // Все прошло гладко возвращаем true
            } else {
                /*
                Если ячейка массива не пуста, работаем с существующим
                односвязным списком. Создаем промежуточную переменную и
                помещаем туда текущее значение (ссылку на) Entry объекта
                под индексом 'position'
                */
                Entry existedElement = (Entry) dst[position];
                /*
                Создаем бесконечный цикл, чтобы перебрать все элементы
                цепочки, т.к. длинна ее нам не известна, а добраться до
                ее хвоста (последнего элемента) нам надо.
                */
                while (true) {
                    /*
                    Если в текущем односвязном списке существует
                    элемент с таким же 'value', т.е. объект не
                    оригинален, мы не добавляем его в список, а
                    следовательно и в массив, а значит и в наш Set.
                    */
                    if (existedElement.value.equals(elementOfSet)) {
                        // Объект не добавлен возвращаем false и вылетаем из цикла while
                        return false;
                        /*
                        Мы сравниваем текущий элемент односвязного списка
                        с добавляемым. Если у текущего элемента списка ссылка
                        на следующий объект списка null, то это хвост или
                        последний элемент списка в конкретной ячейке массива.
                        */
                    } else if (existedElement.next == null) {
                        /*
                        Значит для того, чтобы продолжить наш односвязный список
                        мы нулевую ссылку предыдущего последнего объекта Entry,
                        переназначаем на добавляемый в список объект. Теперь
                        вновь добавленный элемент сам стоит в хвосте и ссылается
                        на пустоту.
                        */
                        existedElement.next = new Entry(elementOfSet, null);
                        // Элемент добавлен возвращаем true и выходим из цикла while
                        return true;
                    } else {
                        /*
                        Если добавляемый объект оригинальный, т.е. такого нет в
                        односвязном списке в ячейке массива dst[position]. При
                        этом у текущего элемента списка ссылка на следующий объект
                        Entry - не ноль -> existedElement.next !== 0, значит это не
                        конечный элемент списка и мы не можем добавить в него наш
                        новый элемент, поэтому начинаем двигаться по цепочке ссылок
                        в цикле while пока не найдем элемент Entry с нулевой ссылкой
                        на следующий объект в цепочке. Это наш хвост и сработает
                        предыдущий if(existedElement.next == null).
                        */
                        existedElement = existedElement.next;
                    }
                }
            }
        }
        // Метод позволяющий удалять элементы из нашего Set-а
        @Override
        public boolean remove(T elementOfSet) {
            /*
            Сначала рассчитываем в какой ячейке массива искать
            переданный в аргументах объект исходя из его хэша
            */
            int position = getElementPosition(elementOfSet, array.length);
            // Если ячейка пуста (там нет даже первого элемента односвязного списка)
            if (array[position] == null) {
                // Ничего не делаем и возвращаем false
                return false;
            }
            /*
            Идеальный вариант это зарисовать, как работает
            данный кусок кода, но... И так попробую на словах,
            главное если, что потом будет не понятно (или забуду),
            разложить все на бумаге еще раз.

            Данный метод занимается тем, что удаляет элементы из
            нашего листа и тут все просто - у нас массив в каждой
            своей ячейке содержит либо null, либо объект Entry.

            Объект Entry, кроме нужной нам информации - объекта
            SpaceObject, содержит еще и ссылку на следующий объект
            Entry (или ссылку в пустоту), который в свою очередь
            содержит нужную нам информацию и ссылку на следующий
            объект Entry (или ссылку на пустоту)... и т.д.
            Т.е. в идеале, мы имеем в каждой ячейке массива
            односвязный список объектов Entry (в реальности же
            у нас массив из null-ей, единичных объектов Entry и
            односвязных списков из объектов Entry).

            Удалить элемент массива можно просто - поместить в
            интересующую нас ячейку массива null или ссылку на
            другой объект (заменить содержимое ячейки другим
            объектом).

            Удалить элемент из односвязного списка еще проще,
            удалить на него ссылку. Естественно мы не хотим
            терять элементы цепочки, которые, возможно шли
            после него. Поэтому должно произойти переназначение
            ссылок. Элемент, который стоит перед удаляемым
            объектом односвязного списка должен указывать на
            элемент, который стоит после удаляемого объекта.

            Происходит как бы переброска (переназначение)
            указателя мимо удаляемого элемента на следующий
            за ним в списке от стоящего перед ним.

            Как только на объект никто не ссылается он считай
            удален. Поэтому стоит только удалить (заменить)
            объект в ячейке массива без сохранения указателя на
            следующий элемент, можно потерять весь односвязный
            список "помещенный" в эту ячейку.

            Перед удалением искомого объекта, который "хранится в
            объекте" класса Entry мы создаем две временные переменные,
            куда помещаем те самые ссылки на предыдущий и
            последующий объект списка (даже если в списке только
            один элемент).
            */
            Entry preLast = (Entry) array[position]; // Поиск идет с головы списка, запоминаем ее
            Entry last = preLast.next; // И запоминаем следующий после нее объект
            if (preLast.value.equals(elementOfSet)) { // Если удаляемый элемент это голова, то...
                array[position] = last; // ...ее место занимает следующий за ней элемент
                size--; // Уменьшаем размер Set-а на единицу
                return true; // Возвращаем информацию об успешном удалении элемента
            }
            /*
            Если удаляемый элемент не голова, то перебираем весь список
            привязанный к конкретной ячейке массива до самого конца, т.е.
            до тех пор пока не найдем элемент, который ссылается на null.
            */
            while (last != null) {
                // Если текущий элемент last искомый для удаления, то
                if (last.value.equals(elementOfSet)) {
                    /*
                    Переназначаем ссылку элемента списка стоящего перед
                    удаляемым на элемент стоящий после удаляемого, т.е.
                    искомый элемент вырезается из списка.
                    */
                    preLast.next = last.next;
                    size--; // Декрементируем размер Set - а
                    return true; // Подтверждаем факт удаления и выходим из цикла
                } else {
                    /*
                    Если текущий элемент last не совпал с элементом для
                    удаления, то продолжаем перебор элементов списка в
                    цикле пока не дойдем до ссылки на null или искомого
                    совпадения.
                    */
                    preLast = last;
                    last = last.next;
                }
            }
            /*
            Если мы прошли весь цикл (весь односвязный список),
            но так и не нашли элемента для удаления - возвращаем
            false и не изменяем size.
            */
            return false;
        }
        // Получаем текущий размер Set-а
        @Override
        public int size() {
            return size;
        }
        // Обнуляем наш Set
        @Override
        public void clear() {
            array = new Object[INITIAL_CAPACITY];
            size = 0;
        }
    // Метод позволяющий определить содержится ли искомый элемент в коллекции
    @Override
    public boolean contains(T elementOfSet) {
        Object[] currentArray = this.array; // Обращаемся к текущему массиву
        T elementForFind = elementOfSet; // Выделяем искомый объект
        boolean contains = false; // Определяем возвращаемое состояние по умолчанию
        Entry nextEntryForFindElement; // Задаем переменную для перебора всего Set-а
        for (int i = 0; i < this.array.length; i++) {
            // Обращаемся к элементам массива (т.е. к головам односвязных цепочек объектов)
            nextEntryForFindElement = (Entry) currentArray[i];
            // При наличии элемента в ячейке массива (т.е. не NULL) начинаем перебирать всю цепь
            if (nextEntryForFindElement != null) {
                /*
                Перебираем все элементы односвязного списка в
                конкретной ячейке массива, пока ссылка на
                следующий элемент текущего Entry объекта не
                будет null или конец цепочки.
                */
                while (nextEntryForFindElement != null) {
                    /*
                    При переборе элементов, просто сравниваем
                    их value по-содержимому, в объекте, который
                    содержится в переменной value желательно
                    пере определить методы hash и equals
                    */
                    if (elementForFind.equals(nextEntryForFindElement.value)){
                        // Искомый элемент найден, ключ - true, поиск окончен, т.к. это Set.
                        contains = true;
                        if (contains){
                            break;
                        }
                    }
                    // Переназначаем ссылку на следующий элемент
                    nextEntryForFindElement = nextEntryForFindElement.next;
                }
            }
        }
        // Возвращаем результат
        return contains;
    }
    /*
    Метод определяющий пуста ли наша коллекция или нет.
    Метод может быть максимально коротким если size = 0,
    то коллекция пуста - все.

    Но мы учимся и данная реализация, хоть и
    'масло-масленное' позволяем выявить дополнительные
    ошибки кода, если заполнение элементами коллекции и
    инкремент и декремент счетчика имеют некий 'рассинхрон'.
    */
    @Override
    public boolean isEmpty() {
        // Обращаемся к текущему массиву
        Object[] currentArray = this.array;
        // Задаем первоначальное состояние переменной 'заполнен/не заполнен'
        boolean empty = true;
        // Перебираем внутренний массив формирующий Set
        for (int i = 0; i < this.array.length; i++) {
            // Нам нужно найти хотя бы один непустой головной элемент
            Entry possiblyNotAnEmptyElement = (Entry) currentArray[i];
            // Если таковой есть меняем флаг 'пустоты коллекции' на false
            if (possiblyNotAnEmptyElement != null) {
                empty = false;
                break;
            }
        }
        /*
        Тут мы применяем то самое 'масло-масленное' или
        избыточную проверку текущего состояния заполненности
        коллекции. Совмещаем проверку размера коллекции и
        поэлементный прогон. Если оба true, то и коллекция
        гарантировано пуста.

        true && false = false // Evaluates false because the second is false
        false && true = false // Evaluates false because the first is false
        true && true = true // Evaluates true because both are true
        false && false = false// Evaluates false because both are false
        */
        return (size == 0 && empty);
    }


    /*
    Метод увеличивающий размер массива,
    на базе которого построен наш Set.
    */
        private void increaseArray() {
            /*
            Создаем новый массив Entry с размером вдвое больше чем был
            */
            Object[] newArray = new Object[array.length * 2];
            /*
            Перебираем в цикле наш текущий массив, для того чтобы
            перенести в новый массив с увеличенной емкостью.
            */
            for (Object entry : array) {
                /*
                Создаем промежуточную переменную 'существующий элемент'
                и помещаем туда текущее содержимое ячейки старого массива.
                */
                Entry existedElement = (Entry) entry;
                /*
                Как я писал выше, для работы со всем односвязным списком,
                нам нужен только первый его элемент, который ссылается на
                следующий и т.д. А значит, по факту, в массиве увеличенного
                размера мы будем оперировать только первым элементом (головой)
                каждого односвязного списка извлекаемого из старого массива,
                но затем...

                Мы берем головной элемент из ячейки исходного массива и
                проверяем существует ли он, если он существует, то...
                */
                while (existedElement != null) {
                    /*
                    ... используя приватный метод *.add() добавляем выбранный
                    элемент в новый массив, в ячейку (или односвязный список в
                    расчетной ячейке)
                    */
                    add(existedElement.value, newArray);
                    /*
                    Получаем ссылку на следующий элемент односвязного списка,
                    если он есть цикл продолжает работу и мы извлекаем следующий
                    элемент списка, если ссылка на следующий элемент текущей
                    цепочки null, то цикл while завершается. Т.е. мы распределили
                    элементы односвязного списка из текущей (n-ой) ячейки старого
                    массива по ячейкам и цепочкам нового массива с увеличенным
                    размером.
                    */
                    existedElement = existedElement.next;
                }
                /*
                Так, в цикле for мы перебираем первые элементы односвязных
                списков лежащие в ячейках массива нашего Set-а (необязательно
                в каждой ячейке), а в цикле while перебираем элементы
                односвязных списков начинающихся с этих самых первых (головных)
                элементов.

                Таким образом все элементы старого массива будут перераспределены
                по ячейкам и спискам нового массива.
                */
            }
            /*
            Теперь ссылка на старый массив переназначается на новый массив.

            Т.е. в данном методе мы создали новый массив, разместили в него
            согласно расчетам элементы старого массива и ссылку, указывающую
            на старый массив, перенаправили на новый.

            Мы ничего специально не удаляли,
                    на объект ссылке нет, он пойдет
                        на обед... сборщику мусора.
            */
            array = newArray;
        }
        /*
        Определяем в какую ячейку массива поместить наш добавляемый объект.
        В качестве аргументов передаем наш объект и текущий размер внутреннего
        массива Set-а.
        Пример (исходный размер массива 16):
        *.hashCode() = 16 => 16 % 16 = 0 => объект помещается в ячейку [0];
        *.hashCode() = 17 => 17 % 16 = 1 => объект помещается в ячейку [1];
        ...
        ...
        *.hashCode() = 15599 => 15599 % 16 = 15 => объект помещается в ячейку [15];

        Естественно если размер массива вырастит, то придется делать
        перераспределение элементов HashSet - а (перерасчет позиций)
        */
        private int getElementPosition(T elementOfSet, int arrayLength) {
            return Math.abs(elementOfSet.hashCode() % arrayLength);
        }

    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            int index = 0;
            int arrayIndex = 0;
            Entry entry;
            Entry curEntry;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public T next() {
                while (array[arrayIndex] == null) {
                    arrayIndex++;
                }
                if (entry == null) {
                    entry = (Entry) array[arrayIndex];
                }
                T result = entry.value;
                curEntry = entry;
                entry = entry.next;
                if (entry == null) {
                    arrayIndex++;
                }
                index++;
                return result;
            }

            @Override
            public void remove(){
                MyOwnHashSet.this.remove(curEntry.value);
                index--;
            }
        };
    }

    /*
    Внутри нашего ХэшСэта есть приватный статический объект Entry
    (вхождение, вход). Он содержит два поля:
    - ссылку на следующий объект Entry;
    - груз - данные, которые мы храним в этом Entry, т.е. ссылка
      на нужную нам информацию.

    По факту, из наших Entry можно сделать, простой односвязный
    список, когда текущий элемент знает только о том, кто стоит
    после него, и чтобы обойти весь список, нужно начинать с его
    головы (первого элемента односвязного списка).

    Вот этой возможностью мы воспользуемся при реализации HashSet-а
    */

        // !!! Сделаем данный класс не статическим чтобы он нормально принимал <T> !!!
        private class Entry {
            private T value; // Хранимый объект
            private Entry next; // Ссылка на следующий Entry
            // Конструктор принимает 'груз' и ссылку на следующий Entry
            public Entry(T value, Entry next) {
                this.value = value;
                this.next = next;
            }

            public T getValue() {
                return value;
            }

            @Override
            public String toString() {
                return "Entry: {" +
                        "value=" + value +
                        '}';
            }

        }

    public Object[] allHashSetElementToSimpleArray() {
        Object[] currentArray = this.array;
        Object[] allElementOfSet = new Object[size];
        int j = 0;
        Entry nextEntryForNewArray;
        for (int i = 0; i < this.array.length; i++) {
            nextEntryForNewArray = (Entry) currentArray[i];
            if (nextEntryForNewArray != null) {
                while (nextEntryForNewArray != null) {
                    allElementOfSet[j] = nextEntryForNewArray;
                    j++;
                    nextEntryForNewArray = nextEntryForNewArray.next;
                }
            }
        }
        return allElementOfSet;
    }
}
